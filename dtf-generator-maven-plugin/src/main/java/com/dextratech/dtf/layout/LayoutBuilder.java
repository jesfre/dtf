//
// Developed by Dextra Technologies www.dextratech.com
//
package com.dextratech.dtf.layout;

import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.apache.commons.io.FileUtils;
import org.apache.commons.lang.StringUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.maven.plugin.MojoExecutionException;
import org.htmlparser.Node;
import org.htmlparser.Parser;
import org.htmlparser.filters.TagNameFilter;
import org.htmlparser.tags.TableColumn;
import org.htmlparser.tags.TableRow;
import org.htmlparser.util.NodeIterator;
import org.htmlparser.util.NodeList;
import org.htmlparser.util.ParserException;

import com.dextratech.dtf.Constants;
import com.dextratech.dtf.DtfAbstractMojo;
import com.dextratech.dtf.SeleneseHtmlColumnIndex;
import com.dextratech.dtf.SpecialCommand;
import com.dextratech.dtf.html2java.Html2JavaConverterHtmlDefined;
import com.dextratech.dtf.parser.DatasetExcelWriter;

/**
 * Goal que ayuda en la tarea de generar una plantilla a partir de un HTML
 * generado por Selenium agregando wildcards del estilo de Velocity.
 * 
 * @goal build-layout
 * @phase process-sources
 * @author <a href="mailto:jorge.ruiz.aquino@gmail.com">Jorge Ruiz Aquino<a>
 *         19/06/2012
 *         Modified by Jarib Sanchez / 21-06-2012
 *         Modified by <a href="mailto:jorge.ruiz.aquino@gmail.com">Jorge Ruiz Aquino</a> / 03/05/2013 / 17/05/2013
 */
@Deprecated
public class LayoutBuilder extends DtfAbstractMojo {
	private static Log log = LogFactory.getLog(LayoutBuilder.class);

	/**
	 * Location of the HTML test case file generated by the Selenium IDE.
	 * @parameter expression="${basedir}/src/test/resources/base-layouts/"
	 * @required
	 */
	private File baseLayoutsPath;

	private Parser parser;
	private static URL urlFile;
	private List<String> keys = null;

	public void execute() throws MojoExecutionException {

		Iterator<File> fileIt = FileUtils.iterateFiles(baseLayoutsPath, new String[] { "html" }, false);
		for (int count = 0; fileIt.hasNext(); count++) {
			File htmlFile = fileIt.next();
			String excelFileLocation = generatedDatasetsPath;
			keys = new ArrayList<String>();

			parseAndCreateWilcards(htmlFile);
			try {
				String shortFileName = StringUtils.substringBeforeLast(htmlFile.getName(), ".");
				excelFileLocation += shortFileName + ".xls";
				createExcelDatasourceLayout(excelFileLocation);
			} catch (Exception e) {
				log.error("Error building dataset layout: " + e.getMessage());
				e.printStackTrace();
			}
		}
	}

	/**
	 * @param shortFinalName The html layout filename without .extension.
	 * @throws Exception
	 */
	private void createExcelDatasourceLayout(String excelFileLocation) {
		try {
			DatasetExcelWriter writer = new DatasetExcelWriter(excelFileLocation);
			writer.writeDataset(keys);
		} catch (Exception e) {
			log.error("Cant generate Excel layout...");
		}
	}

	private void parseAndCreateWilcards(File html) {
		int contTypes = 0;
		String pagina = "";
		try {
			/*
			 * Parsea el HTML base
			 */
			parser = new Parser(html.getAbsolutePath());
			NodeList nodeList = new NodeList();

			/*
			 * Obtien todos los TR
			 */
			TagNameFilter filter = new TagNameFilter("TR");
			for (NodeIterator e = parser.elements(); e.hasMoreNodes();) {
				e.nextNode().collectInto(nodeList, filter);
			}

			/*
			 * Para cada row compara la cantidad de columnas, si la cantidad es
			 * mayor o igual a 3 entonces obtiene la tercera columna que
			 * corresponde al TD que contiene el valor y lo cambia por un
			 * wildcard.
			 */

			log.debug("---\tCOMMANDS\t---");
			for (NodeIterator it = nodeList.elements(); it.hasMoreNodes();) {
				Node node = it.nextNode();
				TableRow row = (TableRow) node;
				int colCount = row.getColumnCount();
				if (colCount == 3) {
					TableColumn tdCommand = row.getColumns()[SeleneseHtmlColumnIndex.COMMAND.getIndex()];
					String command = tdCommand.getStringText();
					StringBuilder debugMsg = new StringBuilder("\t");
					if (StringUtils.isNotBlank(command)) {
						debugMsg.append(command);
					}
					debugMsg.append(" | ");

					TableColumn tdTarget = row.getColumns()[SeleneseHtmlColumnIndex.TARGET.getIndex()];
					String target = tdTarget.getStringText();
					String targetNameForWildcard = "";
					try {
						/* Por cada comando, determina si es un comando de un solo parametro (comandos especiales) 
						 * de un listado de comandos, ya que estos tambien podran ser valores configurables.
						 */
						createPatternWildcard(contTypes, command, tdTarget);
						contTypes++;
					} catch (Exception e) {
						// Catchs IllegalArgumentException, NullPointerException
						// Do nothing
					}

					if (StringUtils.isNotBlank(target)) {
						debugMsg.append(target);

						/* Obtiene el nombre, id, xpath que usa para obtener el 
						 * elemento objetivo para usarlo como wildcard
						 */
						int eqIndex = target.indexOf('=');
						targetNameForWildcard = target.substring(eqIndex + 1);
					}
					debugMsg.append(" | ");

					TableColumn tdValue = row.getColumns()[SeleneseHtmlColumnIndex.VALUE.getIndex()];

					String value = tdValue.getStringText();
					if (StringUtils.isNotBlank(value)) {
						contTypes++;
						createValueWildcard(contTypes, targetNameForWildcard, tdValue);
						debugMsg.append(value);
					}
					log.debug("\n" + debugMsg.toString() + "\n");
				}
				// obtengo el contenido del html de la pagina completa
				pagina = node.getParent().getParent().getParent().toHtml();

			}
			escribeArchivo(html.getName(), generatedLayoutsPath, pagina);
		} catch (ParserException e) {
			e.printStackTrace();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	/**
	 * Create a wildcard for patterns.
	 * @param contTypes
	 * @param command
	 * @param tdPattern
	 * @return
	 * @throws Exception
	 */
	private void createPatternWildcard(int contTypes, String command, TableColumn tdPattern) throws Exception {
		SpecialCommand specComm = SpecialCommand.valueOf(command.trim());
		if (specComm != null) {
			for (NodeIterator itValue = tdPattern.elements(); itValue.hasMoreNodes();) {
				Node nodeValue = itValue.nextNode();
				String key = Constants.WILDCARD_PREFIX + "_" + (contTypes + 1) + "_" + command + Constants.WILDCARD_POSTFIX;
				nodeValue.setText(key);
				keys.add(key);
			}
		}
	}

	/**
	 * Create a wildcard for a value of selenese.
	 * @param contTypes
	 * @param targetNameForWildcard
	 * @param tdValue
	 * @throws ParserException
	 */
	private void createValueWildcard(int contTypes, String targetNameForWildcard, TableColumn tdValue)
			throws ParserException {
		for (NodeIterator itValue = tdValue.elements(); itValue.hasMoreNodes();) {
			Node nodeValue = itValue.nextNode();
			String key = Constants.WILDCARD_PREFIX + "_" + contTypes + "_" + targetNameForWildcard + Constants.WILDCARD_POSTFIX;
			nodeValue.setText(key);
			keys.add(key);
		}
	}

	/***
	 * @param nombre
	 *        - Nombre del Archivo
	 * @param ruta
	 *        - Ubicacion donde se guardara el archivo
	 * @param contenido
	 *        - Es el contenido del archivo que seraguradado
	 */
	private void escribeArchivo(String nombre, String ruta, String contenido) {

		File f = new File(ruta + nombre);
		// se crea el directorio donde se guardara el archivo generado
		new File(ruta).mkdirs();

		// sie el archivo existe lo elimino
		if (f.exists()) {
			f.delete();
			log.debug("Se elimino el archivo");
		}

		// si no existe, se crea con la codificacion UTF8
		if (!f.exists()) {
			try {
				FileUtils.writeStringToFile(f, contenido, "UTF8");
				log.debug("Nueva plantilla en " + f.getAbsolutePath());
			} catch (IOException e) {
				e.printStackTrace();
			}
		}

	}

	public File getHtmlFilesLocation() {
		return baseLayoutsPath;
	}

}
